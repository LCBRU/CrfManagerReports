<crf:areaConfiguration xmlns:crf="http://www.crfmanager.com/system/xml">
  <crf:comment>
    <crf:version>S00033V01</crf:version>
    <crf:analysis>Data administration</crf:analysis>
    <crf:analysis>Users</crf:analysis>
    <crf:analysis></crf:analysis>
    <crf:summary>Report on active user accounts</crf:summary>
    <crf:notes>
    Simple report providing name and email for all active user accounts
    </crf:notes>
    <crf:InternalNotes>
    </crf:InternalNotes>
  </crf:comment>
  <crf:queryBatch>
    <crf:query name="parameters">
      <crf:searchOptions>
        <crf:parameter name="StartMonth" type="int" displayName="Starting on the 1&lt;sup&gt;st&lt;/sup&gt; of">
          <crf:query>
            DECLARE @Months TABLE (
            TextField NVARCHAR(10),
            ValueField INT
            )

            INSERT INTO @Months (TextField,ValueField) VALUES ('January',1);
            INSERT INTO @Months (TextField,ValueField) VALUES ('February',2);
            INSERT INTO @Months (TextField,ValueField) VALUES ('March',3);
            INSERT INTO @Months (TextField,ValueField) VALUES ('April',4);
            INSERT INTO @Months (TextField,ValueField) VALUES ('May',5);
            INSERT INTO @Months (TextField,ValueField) VALUES ('June',6);
            INSERT INTO @Months (TextField,ValueField) VALUES ('July',7);
            INSERT INTO @Months (TextField,ValueField) VALUES ('August',8);
            INSERT INTO @Months (TextField,ValueField) VALUES ('September',9);
            INSERT INTO @Months (TextField,ValueField) VALUES ('October',10);
            INSERT INTO @Months (TextField,ValueField) VALUES ('November',11);
            INSERT INTO @Months (TextField,ValueField) VALUES ('December',12);

            SELECT TextField,ValueField FROM @Months;
          </crf:query>
          <crf:parameter name="StartYear" type="int" displayName=" " maxLength="4" />
        </crf:parameter>

        <crf:parameter name="EndMonth" type="int" displayName="and ending before 1&lt;sup&gt;st&lt;/sup&gt; of">
          <crf:query>
            DECLARE @Months TABLE (
            TextField NVARCHAR(10),
            ValueField INT
            )

            INSERT INTO @Months (TextField,ValueField) VALUES ('January',1);
            INSERT INTO @Months (TextField,ValueField) VALUES ('February',2);
            INSERT INTO @Months (TextField,ValueField) VALUES ('March',3);
            INSERT INTO @Months (TextField,ValueField) VALUES ('April',4);
            INSERT INTO @Months (TextField,ValueField) VALUES ('May',5);
            INSERT INTO @Months (TextField,ValueField) VALUES ('June',6);
            INSERT INTO @Months (TextField,ValueField) VALUES ('July',7);
            INSERT INTO @Months (TextField,ValueField) VALUES ('August',8);
            INSERT INTO @Months (TextField,ValueField) VALUES ('September',9);
            INSERT INTO @Months (TextField,ValueField) VALUES ('October',10);
            INSERT INTO @Months (TextField,ValueField) VALUES ('November',11);
            INSERT INTO @Months (TextField,ValueField) VALUES ('December',12);

            SELECT TextField,ValueField FROM @Months;
          </crf:query>
          <crf:parameter name="EndYear" type="int" displayName=" " maxLength="4" />
        </crf:parameter>

        <crf:parameter name="OwnerList" type="nvarchar" displayName="Owning Site" multiSelect="true" initialSelection="All">
          <crf:query>
            SET NOCOUNT ON;

            SELECT
              r.ResourceID AS ValueField,
              r.RName AS TextField
            FROM 	WTCRFResources r
            JOIN 	view_ResourceOptions ro
              ON ro.ResourceID = r.ResourceID
            WHERE 	r.RResourceType = 1016 -- CRF Sites
              AND r.ResourceID IN (
                SELECT ro.ResourceID
                FROM view_ResourceOptions ro
                WHERE ROTValue = 'OWNER'
              )
            ;
          </crf:query>
        </crf:parameter>

      </crf:searchOptions>

      <crf:statement>
        SET NOCOUNT ON;

        DECLARE @StartDate DATETIME;
        DECLARE @EndDate DATETIME;
        DECLARE @start_time TIME = '8:30'
        DECLARE @end_time TIME = '16:00'


        SELECT @StartDate = DATETIMEFROMPARTS (
          (SELECT WSFValue FROM WTCRFStateFields WHERE WSFName='StartYear' AND WSFStateID=@ItemID),
          (SELECT WSFValue FROM WTCRFStateFields WHERE WSFName='StartMonth' AND WSFStateID=@ItemID),
          1, 0, 0, 0, 0
        )

        SELECT @EndDate = DATETIMEFROMPARTS (
          (SELECT WSFValue FROM WTCRFStateFields WHERE WSFName='EndYear' AND WSFStateID=@ItemID),
          (SELECT WSFValue FROM WTCRFStateFields WHERE WSFName='EndMonth' AND WSFStateID=@ItemID),
          1, 0, 0, 0, 0
        )

        SELECT NULL;

      </crf:statement>
    </crf:query>

    <crf:query name="owners">
      <crf:statement>
        SET NOCOUNT ON;

        DECLARE @OwnerList NVARCHAR(MAX);

        CREATE TABLE #owners(
          id UNIQUEIDENTIFIER NOT NULL PRIMARY KEY
        );

        SELECT @OwnerList = WSFValue
        FROM WTCRFStateFields
        WHERE WSFName='OwnerList'
          AND WSFStateID=@ItemID;
        
        INSERT INTO #owners(id)
        SELECT o.ItemID
        FROM dbo.get_UniqueIdentifierTable(@OwnerList) o

        SELECT NULL;
      </crf:statement>
    </crf:query>

    <crf:query name="dates">
      <crf:statement>
        SET NOCOUNT ON;

        CREATE TABLE #dates(
          today DATE NOT NULL,
          tomorrow DATE NOT NULL,
          day_of_week NVARCHAR(50) NOT NULL,
          is_weekend BIT NOT NULL,
          core_start_date_time DATETIME NULL,
          core_end_date_time DATETIME NULL,
          core_minutes INT NOT NULL
        );

        CREATE CLUSTERED INDEX #idx_dates ON #dates(today);

        ;WITH seq(n) AS 
        (
          SELECT 0 UNION ALL SELECT n + 1 FROM seq
          WHERE n &lt; DATEDIFF(DAY, @StartDate, @EndDate)
        ), d(d) AS
        (
          SELECT DATEADD(DAY, n, @StartDate)
          FROM seq
        ), date_details(today, tomorrow, day_of_week, is_weekend, core_start_date_time, core_end_date_time) AS
        (
          SELECT
            d AS today,
            DATEADD(DAY, 1, d) tomorrow,
            DATENAME(weekday, d) day_of_week,
            CASE WHEN DATEPART(WEEKDAY, d) IN (1, 7) THEN 1 ELSE 0 END is_weekend,
            CAST(d AS DATETIME) + CAST(@start_time AS DATETIME) core_start_date_time,
            CAST(d AS DATETIME) + CAST(@end_time AS DATETIME) core_end_date_time
          FROM d
        )

        INSERT INTO #dates (today, tomorrow, day_of_week, is_weekend, core_start_date_time, core_end_date_time, core_minutes)
        SELECT
          today,
          tomorrow,
          day_of_week,
          is_weekend,
          core_start_date_time,
          core_end_date_time,
          DATEDIFF(MINUTE, core_start_date_time, core_end_date_time) core_minutes
        FROM date_details
        WHERE is_weekend = 0

        UNION

        SELECT
          today,
          tomorrow,
          day_of_week,
          is_weekend,
          NULL,
          NULL,
          0
        FROM date_details
        WHERE is_weekend = 1

        OPTION (MAXRECURSION 0);

        SELECT NULL;
      </crf:statement>
    </crf:query>

    <crf:query name="merge_events_to_periods">
      <crf:statement>
        SET NOCOUNT ON;

        CREATE TABLE #merging_events (
          id INT IDENTITY(1,1) NOT NULL,
          resource_id NVARCHAR(50) NOT NULL,
          is_other BIT NOT NULL,
          start_date_time DATETIME2(7) NOT NULL,
          end_date_time DATETIME2(7) NOT NULL,
          merged_min_id NVARCHAR(50) NULL,
        );

        CREATE NONCLUSTERED INDEX #idx_merging_events_id ON #merging_events(id);
        CREATE NONCLUSTERED INDEX #idx_merging_events ON #merging_events(resource_id, is_other, start_date_time, end_date_time);

        INSERT INTO #merging_events (resource_id, is_other, start_date_time, end_date_time)
        SELECT
          re.ResourceID,
          CASE
            WHEN re.REAreaID = 301 THEN 0
            ELSE 1
          END,
          re.TStartDate,
          re.TEndDate
        FROM view_ResourceEvents re
        JOIN #owners o
          ON o.id = re.ROwnerID
        WHERE re.REStatusID NOT IN (
            5871, -- Cancelled
            5869 -- Unused
          )
          AND re.TStartDate &lt; @EndDate
          AND re.TEndDate &gt; @StartDate
        ;

        UPDATE #merging_events SET merged_min_id = id;

        CREATE TABLE #to_update (
          id INT NOT NULL,
          merged_min_id INT NOT NULL
        );

        DECLARE @todo INT;
        SET @todo = 1
        DECLARE @iterations INT;
        SET @iterations = 0

        WHILE (@todo &gt; 0 AND @iterations &lt; 20)
        BEGIN
          TRUNCATE TABLE #to_update;

          INSERT INTO #to_update (id, merged_min_id)
          SELECT a2.id, MIN(a1.merged_min_id)
          FROM #merging_events a1
          JOIN #merging_events a2
            ON a2.resource_id = a1.resource_id
            AND a2.is_other = a1.is_other
            AND a2.start_date_time &lt;= a1.end_date_time
            AND a2.end_date_time &gt;= a1.start_date_time
            AND a2.merged_min_id &gt; a1.merged_min_id
          GROUP BY a2.id
          ;

          CREATE NONCLUSTERED INDEX #idx_to_update ON #to_update(id);

          UPDATE a
          SET a.merged_min_id = u.merged_min_id
          FROM #merging_events a
          JOIN #to_update u
            ON u.id = a.id
          ;

          SELECT @todo = COUNT(*) FROM #to_update;

          DROP INDEX #idx_to_update ON #to_update;

          SET @iterations = @iterations + 1

        END

        CREATE TABLE #periods(
          id INT IDENTITY(1,1) NOT NULL,
          merged_min_id INT NOT NULL,
          resource_id NVARCHAR(50) NOT NULL,
          start_date_time DATETIME2(7) NOT NULL,
          end_date_time DATETIME2(7) NOT NULL,
          start_date DATE NOT NULL,
          end_date DATE NOT NULL,
          records_mrged INT NOT NULL,
          is_other BIT NOT NULL
        );

        INSERT INTO #periods (merged_min_id, resource_id, [start_date_time], [end_date_time], [start_date], [end_date], records_mrged, is_other)
        SELECT
          merged_min_id,
          resource_id,
          MIN(start_date_time) AS start_date_time,
          
          MAX(end_date_time) AS end_date_time,
          CONVERT(DATE, MIN(start_date_time)) AS start_date,
          CONVERT(DATE, MAX(end_date_time)) AS end_date,
          COUNT(*),
          is_other
        FROM #merging_events
        GROUP BY resource_id, merged_min_id, is_other
        ;

        CREATE NONCLUSTERED INDEX #IX_periods ON #periods(resource_id ASC);

        DROP TABLE #merging_events;
        DROP TABLE #to_update;

        SELECT NULL;
      </crf:statement>
    </crf:query>

    <crf:query name="day_minutes">
      <crf:statement>
        SET NOCOUNT ON;

        CREATE TABLE #resource_day_minutes(
          date DATE NOT NULL,
          resource_id NVARCHAR(50) NOT NULL,
          other_ooh_minutes INT NOT NULL,
          other_in_hours_minutes INT NOT NULL,
          patient_ooh_minutes INT NOT NULL,
          patient_in_hours_minutes INT NOT NULL
        );

        WITH period_days AS (
          SELECT
            op.resource_id,
            d.today periodday_date,
            IIF(d.today &gt; op.start_date_time, d.today, op.start_date_time) periodday_start_date_time,
            IIF(d.tomorrow &lt; op.end_date_time, d.tomorrow, op.end_date_time) periodday_end_date_time,
            op.is_other
          FROM #periods op
          JOIN #dates d
            ON d.today &gt;= op.start_date
            AND d.today &lt;= op.end_date
        ), period_days_minutes AS (

          SELECT
            pd.resource_id,
            pd.[date],
            pd.start_date_time AS start_date_time,
            d.core_start_date_time AS end_date_time,
            1 AS out_of_hours,
            DATEDIFF(MINUTE, pd.start_date_time, d.core_start_date_time) AS minutes,
            pd.is_other
          FROM period_days pd
          JOIN #dates d
            ON d.today = pd.date
          WHERE pd.start_date_time &lt; d.core_start_date_time

          UNION

          SELECT
            pd.resource_id,
            pd.[date],
            d.core_end_date_time AS start_date_time,
            pd.end_date_time AS end_date_time,
            1 AS out_of_hours,
            DATEDIFF(MINUTE, d.core_end_date_time, pd.end_date_time) AS minutes,
            pd.is_other
          FROM period_days pd
          JOIN #dates d
            ON d.today = pd.date
          WHERE pd.end_date_time &gt; d.core_end_date_time

          UNION

          SELECT
            resource_id,
            [date],
            start_date_time,
            end_date_time,
            0 AS out_of_hours,
            DATEDIFF(MINUTE, start_date_time, end_date_time) AS minutes,
            is_other
          FROM (
            SELECT
              pd.resource_id,
              pd.[date],
              pd.is_other,
              IIF(pd.start_date_time &gt; d.core_start_date_time, pd.start_date_time, d.core_start_date_time) AS start_date_time,
              IIF(pd.end_date_time &lt; d.core_end_date_time, pd.end_date_time, d.core_end_date_time) AS end_date_time
            FROM period_days pd
            JOIN #dates d
              ON d.today = pd.date
            WHERE pd.start_date_time &lt; d.core_end_date_time
              AND pd.end_date_time &gt; d.core_start_date_time
          ) x
        )

        SELECT
            p.resource_id,
            p.[date],
            p.start_date_time,
            p.end_date_time,
            p.out_of_hours,
            p.minutes,
            p.is_other
        FROM period_days_minutes p
        ;
      </crf:statement>
    </crf:query>

  </crf:queryBatch>

  <crf:body id="1" title="Print format" format="text/xml">
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:crf-utils="crf:utilities" version="1.0">
      <xsl:output method="html" indent="yes" omit-xml-declaration="yes" />
      <xsl:template match="NewDataSet">
        <div>
          <table class="grid">
            <thead>
              <td>resource_id</td>
              <td>date</td>
              <td>start_date_time</td>
              <td>end_date_time</td>
              <td>out_of_hours</td>
              <td>minutes</td>
              <td>is_other</td>
            </thead>
            <tbody>
              <xsl:apply-templates select="day_minutes" />
            </tbody>
          </table>
        </div>
      </xsl:template>
      <xsl:template match="day_minutes">
        <tr>
          <td><xsl:value-of select="resource_id" /></td>
          <td><xsl:value-of select="date" /></td>
          <td><xsl:value-of select="start_date_time" /></td>
          <td><xsl:value-of select="end_date_time" /></td>
          <td><xsl:value-of select="out_of_hours" /></td>
          <td><xsl:value-of select="minutes" /></td>
          <td><xsl:value-of select="is_other" /></td>
        </tr>
      </xsl:template>
    </xsl:stylesheet>
  </crf:body>
</crf:areaConfiguration>